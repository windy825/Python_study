## 부분집합 



**저희 팀분들! 모두 반갑습니다.**

비트연산을 이용한 부분집합 구하기는  약10분정도 특강을 진행할테니, 그때 완벽하게 이해하면 됩니다.

 

오늘 모임 전 할일!

*( &연산 처리방식과 쉬프트 연산의 동작방식 이해하고 오기)*





- **비트연산**

  집합의 원소가 N개라면, 부분집합의 개수는 2^N 입니다.

  (쉬프트연산과 비슷.  1<<N 은 1에 2를 N번 곱하는 것과 동일)

  집합의 각 원소는 독립적이기 때문에, 부분집합에 포함되거나 포함안되거나 2가지 경우의 수를 가집니다.

  ```
  [1,2,3] 의 부분집합의 개수?
  
  1이 포함되거나 안될경우 2가지
  2가 포함되거나 안될경우 2가지
  3이 포함되거나 안될경우 2가지
  
  2 X 2 X 2 => 8개 ( 2^3개 )
  ```

  위에 내용을 비트로 표현한다면??

  ```
  특정 원소가 포함되면? 1 포함되지 않는다면? 0
  
  즉 [1,2,3] 에서
  001 {3}
  010 {2}
  100 {1}
  101 {1,3} 
  으로 표현할 수 있습니다.
  ```



- arr[1,3,5,7] 의  모든 부분집합 구하기


![부분집합 비트](https://user-images.githubusercontent.com/89068148/152642157-aa37b9a1-46a0-41fd-9921-5cffac024d2b.png)

사진처럼, 모든 경우의 수는 0,1,2,3,,,,15번까지 숫자를 가집니다. (4개 원소의 부분집합은 16인데 왜 사진은 15개까지일까?? 공집합을 임의로 뺀것 )

해당 숫자를 비트로 변환했을때, 1이 있는 위치는 arr의 원소 위치라고 보면 됩니다.

1이 있다면 해당 위치의 원소가 포함된 부분집합 입니다.


자 그럼 원소의 개수가 5개라고 가정하고 진행해보겠습니다.

```python
arr = [1,2,3,4,5]
n = len(arr)


모든부분집합 = []

for i in range(2**n):   # 모든 부분집합의 개수를 하나씩 순회함 (0,1,2,3,,,,2^n)
    부분집합 = []
    
    for j in range(n):  # 각 원소마다 조사
        print(i)
        if i & (1<<j):
            부분집합.append(arr[j])  # 일치하는 원소를 부분집합에 담기
    
    모든부분집합.append(부분집합)

print(모든부분집합)

# [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3], 
# [4], [1, 4], [2, 4], [1, 2, 4], [3, 4], [1, 3, 4], [2, 3, 4], 
# [1, 2, 3, 4], [5], [1, 5], [2, 5], [1, 2, 5], [3, 5], [1, 3, 5], 
# [2, 3, 5], [1, 2, 3, 5], [4, 5], [1, 4, 5], [2, 4, 5], [1, 2, 4, 5], 
# [3, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5], [1, 2, 3, 4, 5]]
```



**i & (1<<j)** 

이 지점이 중요합니다.

i에 해당하는 이진수와 (1<<j) 이진수를 비교해서 같은 자리에 둘다 1이 있다면, 

해당되는 자리의 인덱스를 이용해서 arr[j] 값이 부분집합에 포함되게 됩니다.







- **비트 연산**이란?

비트연산은 다소 복잡하나, 연산에서의 효율성이 좋아서 꾸준히 잘 사용되기도 하는 방법입니다.



옛날에는 컴퓨팅 자원 (예를 들면, 하드웨어 성능? 메모리량? 연산처리량?) 등의 자원들이 한정적일때,

특히 메모리 사용이나, 연산처리나 컴파일링 (고급언어로 작성될 경우 이를 컴퓨터가 받아들일 수 있는 저급언어로 변환해야 함) 횟수를 줄이기 위해 사용됩니다.



요즘에는 잘 쓰는지 모르겠습니다만, 하드웨어를 프로그래밍하거나(최대한의 최적화가 필요한) 시스템 프로그래밍 등 제한된 자원을 가지고 만들어져야 할 프로그램에서는 자주 사용될 수 도 있겠습니다.

하지만 지금 고급언어가 등장하고, 컴퓨팅 파워가 끝도없이 향상되고 성능이 우수하기 때문에, 

코딩테스트나 개인 프로젝트 등에서는 잘 쓰이지 않습니다.

아마 기업의 데이터저장소 또는 월등하게 많은 양의 정보를 처리할때는 쓰일 수도 있습니다.



기본적으로 비트 연산자 (`& | & ~ << >>`) 를 이용한 연산시, 

해당 연산의 속도를 향상시키거나 메모리를 절약 할 수 있습니다.



- 왜 빠른가?

  재현의 과정을 거치지 않고 즉시 해석됩니다. 예를 들어서

  ```
  # 2를 곱하는 연산에 대해 살펴 보겠습니다.
  
  4*2  (4*2를 처리하려면 해당 수를 이진수로 바꾸고, *으로 추상화된 연산을 비트연산으로 바꾸고 처리해야 한다.)
  4 << 1 (컴퓨터입장에서는 해당 연산이 자신에게 친숙한 비트연산이기 때문에 더 빠를 수 밖에 없다.
  		특히 <<은 컴퓨터언어로 변환될 필요가 없음)
  ```

